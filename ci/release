#!/usr/bin/env bash
set -euo pipefail

CONFIG_FILE="release.yaml"
GORELEASER_FLAGS=""

print_help() {
  cat <<EOF
Usage: $(basename "$0") [GLOBAL OPTIONS] [--] [BUMP-ARG]

Global options:
-h, --help Show this help
--skip-git-check Skip git repository checks
--skip-tools-check Skip checking required tools
--skip-config Skip reading the config file
--skip-go-generate Skip running 'go generate'
--skip-go-tidy Skip running 'go mod tidy'
--skip-govulncheck Skip running govulncheck
--config-file <file> Path to config file (default: release.yaml)
--myrepo <path> Path to your local repo helper (sets MYREPO)
--goreleaser-flags <flags> Extra flags to pass to goreleaser (quoted)

Any remaining arguments after '--' or unknown options are passed to the 'bump' function
(e.g. major|minor|patch or an explicit version).

EOF
}

function check-git() {
  # Check that inside git repo
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "Not inside git repo; aborting" >&2
    exit 1
  fi

  if [[ "${SKIP_GIT_CHECK-}" == "true" ]]; then
    echo "Skipping git check..."
    return
  fi

  # Check that git index is clean
  if [[ -n "$(git status --porcelain)" ]]; then
    echo "There are uncommitted changes; aborting" >&2
    git status --porcelain
    exit 1
  fi
}

function check-tools() {
  if [[ "${SKIP_TOOLS_CHECK-}" == "true" ]]; then
    echo "Skipping tools check..."
    return
  fi

  deps=(
    "go"
    "golangci-lint"
    "govulncheck"
    "gomod2nix"
    "goreleaser"
    "git"
    "git-cliff"
    "yq"
    "jq"
  )
  for d in "${deps[@]}"; do
    if ! command -v "$d" >/dev/null 2>&1; then
      echo "\"$d\" is not found in current environment; aborting" >&2
      exit 1
    fi
  done
}

function check-myrepo() {
  # If $MYREPO is not empty
  if [[ -n "${MYREPO-}" ]]; then
    # Check if $MYREPO is a valid dir
    if [[ ! -d "$MYREPO" ]]; then
      echo "Env var \$MYREPO is set but it is not a valid dir" >&2
      exit 1
    fi
  fi
}

function check-gpg() {
  # if $DEFAULT_GPG_FPR is not empty
  if [[ -n "${DEFAULT_GPG_FPR-}" ]]; then
    if [ "$(gpg --list-secret-keys --with-colons "$DEFAULT_GPG_FPR" 2>/dev/null | grep "sec")" == "" ]; then
      echo "No private gpg key found for $DEFAULT_GPG_FPR; aborting"
      exit 1
    fi
  fi
}

# Input formats:
#   `pass:path/to/secret:field` - load specific field
#   `pass:path/to/secret` - load whole content of secret file
function load-pass() {
  pass_file="$(echo "$1" | awk -F: '{print $2}')"
  pass_field="$(echo "$1" | awk -F: '{print $3}')"
  if [ "$pass_field" == "" ]; then
    echo "Loading pass secret '$pass_file'..." >&2
    pass show "$pass_file"
  else
    echo "Loading '$pass_field' from pass secret '$pass_file'..." >&2
    pass show "$pass_file" | grep -i -m1 "^[[:space:]]*${pass_field}[[:space:]]*:" | sed -E 's/^[^:]+:[[:space:]]*//'
  fi
}

# Input format:
#   `bitwarden:object_type:id` - load object of specified type with specified id
function load-bitwarden() {
  bw_type="$(echo "$1" | awk -F: '{print $2}')"
  bw_id="$(echo "$1" | awk -F: '{print $3}')"
  echo "Loading '$bw_type' of '$bw_id' from bitwarden" >&2
  bw get "$bw_type" "$bw_id" < /dev/tty
}

# $1 - env variable name
# $2 - source
# If $2 == ENV, env var with name $1 must be set before running this script
function load-secret() {
  if [ "$2" == "ENV" ]; then
    if eval "[ -z \"\${${1}:-}\" ]"; then
        echo "Env var $1 must be set before running this script; aborting"
        exit 1
    fi
    return
  fi
  # Skip loading secret from source if env var with name $1 already set
  if eval "[ ! -z \"\${${1}:-}\" ]"; then
    return
  fi
  source_type=$(echo "$2" | awk -F: '{print $1}')
  case "$source_type" in
    pass)
      SECRET_VALUE="$(load-pass "$2")"
      ;;
    bitwarden)
      SECRET_VALUE="$(load-bitwarden "$2")"
      ;;
    *)
      echo "Unknown secret source type for $1; Check your $CONFIG_FILE; aborting"
      exit 1
      ;;
  esac
  if [ "" == "$SECRET_VALUE" ]; then
    echo "Value of $1 is not set; aborting"
    exit 1
  fi
  export "$1=$SECRET_VALUE"
}

function read-config() {
  if [ "${SKIP_CONFIG-}" == "true" ]; then
    echo "Skipping config reading..."
    return
  fi
  if [ ! -f "$CONFIG_FILE" ]; then
    echo "$CONFIG_FILE not found; aborting"
    exit 1
  fi

  if [ "$(yq -r ".secrets" "$CONFIG_FILE")" != "null" ]; then
    # Load secrets
    while IFS='=' read -r key value; do
      load-secret "$key" "$value"
    done < <(
      yq -r '.secrets  | to_entries[] | "\(.key)=\(.value // "")"' "$CONFIG_FILE"
    )
    # Load regular vars
    while IFS='=' read -r key value; do
      # Skip secrets dict
      if [ "$key" == "secrets" ]; then
        return
      fi
      export "$key=$value"
    done < <(
      yq -r '. | to_entries[] | "\(.key)=\(.value // "")"' "$CONFIG_FILE"
    )
  fi
}

# commit "commit message"
# Do nothing if there is git index is clean
function commit() {
  if [ "$(git status --porcelain)" == "" ]; then
    # Git index is clean
    return
  fi
  git add --all
  git commit -m "$1"
}

function prepare-go() {
  if [ "${SKIP_GO_GENERATE-}" == "true" ]; then
    echo "Skipping go generate..."
  else
    echo "Running go generate..."
    go generate ./...
    commit "chore: apply go generate"
  fi

  if [ "${SKIP_GO_TIDY-}" == "true" ]; then
    echo "Skipping go mod tidy..."
  else
    echo "Running go mod tidy..."
    go mod tidy
    commit "chore: apply go mod tidy"
  fi

  echo "Running tests..."
  go test

  echo "Running golangci-lint..."
  golangci-lint run ./...

  if [ "${SKIP_GOVULN_CHECK-}" == "true" ]; then
    echo "Skipping govulncheck..."
  else
    echo "Running govulncheck..."
    govulncheck
  fi
}

function bump() {
  if [ ! "$#" -gt 0 ]; then
    NEW_VERSION="$(git cliff --bump --context | jq -r .[0].version)"
    CHANGELOG="$(git cliff --bump)"
  else
    # if $1 in major|minor|patch, run git cliff
    if [[ "major|minor|patch" == *"$1"* ]]; then
      NEW_VERSION="$(git cliff --bump "$1" --context | jq -r .[0].version)"
      CHANGELOG="$(git cliff --bump "$1")"
    else
      NEW_VERSION="$1"
      CHANGELOG="$(git cliff --bump --tag "$NEW_VERSION")"
    fi
  fi

  echo "Bumping to $NEW_VERSION"

  # Save with stripping leading v
  echo "${NEW_VERSION#v}" > VERSION

  echo "$CHANGELOG" > CHANGELOG.md

  commit "bump: bump to $NEW_VERSION"

  git tag "$NEW_VERSION"

  echo "Running git push..."
  git push

  echo "Running git push --tag..."
  git push --tags
}

function repo-save() {
  # If $MYREPO is not void
  if [ "${MYREPO-}" != "" ]; then
    "$MYREPO/maintain" save feat "add $PROJECT_NAME $NEW_VERSION"
  fi
}

# --- Parse global options (stop at first non-global or '--') ---
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      print_help
      exit 0
      ;;
    --skip-git-check)
      SKIP_GIT_CHECK=true
      shift
      ;;
    --skip-tools-check)
      SKIP_TOOLS_CHECK=true
      shift
      ;;
    --skip-config)
      SKIP_CONFIG=true
      shift
      ;;
    --skip-go-generate)
      SKIP_GO_GENERATE=true
      shift
      ;;
    --skip-go-tidy)
      SKIP_GO_TIDY=true
      shift
      ;;
    --skip-govulncheck)
      SKIP_GOVULN_CHECK=true
      shift
      ;;
    --config-file)
      CONFIG_FILE="$2"
      shift 2
      ;;
    --myrepo)
      MYREPO="$2"
      shift 2
      ;;
    --goreleaser-flags)
      GORELEASER_FLAGS="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      # stop parsing on first positional (assume it's for bump)
      break
      ;;
  esac
done

check-git
check-tools

# cd to repo root
cd "$(git rev-parse --show-toplevel)"

read-config

echo "TOKENS: $GITHUB_TOKEN $TELEGRAM_TOKEN"

check-gpg

# Check that required variables are set
echo "$PROJECT_NAME $MAINTAINER" > /dev/null

check-myrepo

prepare-go

# - Bump version tag
# - Generate changelog
# - Push
bump "$@"

# Allow extra goreleaser flags from CLI
if [[ -n "${GORELEASER_FLAGS-}" ]]; then
  echo "Running goreleaser with extra flags: ${GORELEASER_FLAGS}"
  goreleaser release --clean ${GORELEASER_FLAGS} --release-notes <(git cliff --latest)
else
  goreleaser release --clean --release-notes <(git cliff --latest)
fi

# Commit packages added to deb/rpm repo (if one was used)
repo-save

